trigger:
  - main

pool:
  vmImage: ubuntu-latest

variables:
  - name: NODE_VERSION
    value: '20'
  - name: REGISTRY
    value: 'ghcr.io'
  - name: GITHUB_ACTOR
    value: 'pmanavella'
  - name: DEPLOY_RENDER
    value: 'true'
  - group: SONAR_TOKEN
  - group: GHCR_SECRETS         # GHCR_TOKEN (secret), GHCR_USERNAME
  - group: RENDER_HOOKS         # hooks y FRONT_QA_URL

stages:

# ──────────────────────────────
# 1) CI: Tests + Sonar
# ──────────────────────────────
- stage: CI
  displayName: 'CI: Tests + Sonar'
  jobs:
    - job: quality
      displayName: 'Quality'
      steps:
        - checkout: self
          clean: true

        - task: NodeTool@0
          displayName: 'Use Node $(NODE_VERSION)'
          inputs:
            versionSpec: '$(NODE_VERSION)'

        - task: SonarCloudPrepare@3
          displayName: 'Sonar • Prepare'
          inputs:
            SonarCloud: 'SonarCloud'
            organization: 'pmanavella'
            projectKey: 'FINAL-IS3'
            scannerMode: 'CLI'
            configMode: 'file'

        - script: |
            set -e
            cd frontend
            npm ci
            npm run test:cov || echo "Vitest warnings, continuamos..."
          displayName: 'Frontend • Vitest + Coverage'

        - task: PublishCodeCoverageResults@2
          displayName: 'Frontend • Publicar Coverage'
          inputs:
            codeCoverageTool: Cobertura
            summaryFileLocation: 'frontend/coverage/cobertura-coverage.xml'
            reportDirectory: 'frontend/coverage'
            failIfCoverageEmpty: false
          condition: always()

        - script: |
            set -e
            cd backend
            npm ci
            npm run test:cov || echo "Jest warnings, continuamos..."
          displayName: 'Backend • Jest + Coverage'

        - task: PublishCodeCoverageResults@2
          displayName: 'Backend • Publicar Coverage'
          inputs:
            codeCoverageTool: Cobertura
            summaryFileLocation: 'backend/coverage/cobertura-coverage.xml'
            reportDirectory: 'backend/coverage'
            failIfCoverageEmpty: false
          condition: always()

        - task: SonarCloudAnalyze@3
          displayName: 'Sonar • Analyze'

        - task: SonarCloudPublish@3
          displayName: 'Sonar • Quality Gate'
          inputs:
            pollingTimeoutSec: '300'

# ──────────────────────────────
# 2) QA: Build & Push (+ opcional Deploy)
# ──────────────────────────────
- stage: QA
  displayName: 'QA: Build & Push (+ opcional Deploy)'
  dependsOn: CI
  condition: succeeded()
  jobs:
    - job: build_push_qa
      displayName: 'Build & Push (latest + sha) + Deploy QA (si aplica)'
      steps:
        - checkout: self
          clean: true

        # Login GHCR
        - bash: |
            set -e
            echo "$GHCR_TOKEN" | docker login "$REGISTRY" -u "$GHCR_USERNAME" --password-stdin
          displayName: 'Login GHCR'
          env:
            GHCR_TOKEN: $(GHCR_TOKEN)
            GHCR_USERNAME: $(GHCR_USERNAME)
            REGISTRY: $(REGISTRY)

        - bash: |
            set -e
            SHORT_SHA="$(echo $(Build.SourceVersion) | cut -c1-7)"
            echo "SHORT_SHA=$SHORT_SHA" > meta.txt
            cat meta.txt
          displayName: 'Compute short sha'

        - bash: |
            set -e
            SHA="$(grep SHORT_SHA meta.txt | cut -d'=' -f2)"
            docker build -t $(REGISTRY)/$(GITHUB_ACTOR)/books-backend:latest \
                          -t $(REGISTRY)/$(GITHUB_ACTOR)/books-backend:sha-$SHA \
                          backend
            docker push $(REGISTRY)/$(GITHUB_ACTOR)/books-backend:latest
            docker push $(REGISTRY)/$(GITHUB_ACTOR)/books-backend:sha-$SHA
          displayName: 'Backend • Build & Push'

        - bash: |
            set -e
            SHA="$(grep SHORT_SHA meta.txt | cut -d'=' -f2)"
            docker build \
              --build-arg VITE_ENV=qa \
              -t $(REGISTRY)/$(GITHUB_ACTOR)/books-frontend:latest \
              -t $(REGISTRY)/$(GITHUB_ACTOR)/books-frontend:sha-$SHA \
              frontend
            docker push $(REGISTRY)/$(GITHUB_ACTOR)/books-frontend:latest
            docker push $(REGISTRY)/$(GITHUB_ACTOR)/books-frontend:sha-$SHA
          displayName: 'Frontend QA • Build (VITE_ENV=qa) & Push'

        # Deploy a Render (opcional)
        - bash: |
            set -e
            if [ "$(DEPLOY_RENDER)" != "true" ] || [ -z "$RENDER_QA_HOOK_FRONT" ] || [ -z "$RENDER_QA_HOOK_BACK" ]; then
              echo "Saltando Deploy QA (Render): faltan hooks o DEPLOY_RENDER != true"
              exit 0
            fi
            echo "Trigger Render FRONT QA"
            curl -fsS -X POST "$RENDER_QA_HOOK_FRONT"
            echo "Trigger Render BACK QA"
            curl -fsS -X POST "$RENDER_QA_HOOK_BACK"
          displayName: 'Deploy QA (Render hooks, opcional)'
          env:
            DEPLOY_RENDER: $(DEPLOY_RENDER)
            RENDER_QA_HOOK_FRONT: $(RENDER_QA_HOOK_FRONT)
            RENDER_QA_HOOK_BACK: $(RENDER_QA_HOOK_BACK)

        # Espera a que FRONT_QA_URL responda 200 (hasta ~10 min)
        - bash: |
            set -e
            if [ "$(DEPLOY_RENDER)" != "true" ] || [ -z "$FRONT_QA_URL" ]; then
              echo "Saltando espera: no hay FRONT_QA_URL o DEPLOY_RENDER != true"
              exit 0
            fi
            echo "Esperando a que $FRONT_QA_URL responda 200..."
            ATTEMPTS=60
            SLEEP=10
            i=1
            STATUS=000
            until [ $i -gt $ATTEMPTS ]; do
              STATUS=$(curl -sk -o /dev/null -w "%{http_code}" "$FRONT_QA_URL")
              if [ "$STATUS" = "200" ]; then
                echo "OK ($STATUS) en intento $i"
                break
              fi
              echo "Intento $i/$ATTEMPTS → HTTP $STATUS. Reintentando en ${SLEEP}s..."
              sleep $SLEEP
              i=$((i+1))
            done
            if [ "$STATUS" != "200" ]; then
              echo "No alcanzó estado 200 en el tiempo esperado."
              exit 1
            fi
          displayName: 'Wait until FRONT_QA_URL is healthy'
          env:
            DEPLOY_RENDER: $(DEPLOY_RENDER)
            FRONT_QA_URL: $(FRONT_QA_URL)

        # Cypress E2E (opcional, con retries y headless)
        - bash: |
            set -e
            if [ "$(DEPLOY_RENDER)" != "true" ] || [ -z "$FRONT_QA_URL" ]; then
              echo "Saltando Cypress: no hay FRONT_QA_URL o DEPLOY_RENDER != true"
              exit 0
            fi
            cd frontend
            npm ci
            npx cypress install
            # Pasamos baseUrl por env y agregamos retries
            export CYPRESS_baseUrl="$FRONT_QA_URL"
            export CYPRESS_video=false
            npx cypress run --browser chrome --headless --config retries=2
          displayName: 'Cypress E2E (QA, opcional)'
          env:
            DEPLOY_RENDER: $(DEPLOY_RENDER)
            FRONT_QA_URL: $(FRONT_QA_URL)
          continueOnError: true

# ──────────────────────────────
# 3) PROD: Approval → Promote & Deploy
# ──────────────────────────────
- stage: PROD
  displayName: 'PROD: Approval → Promote & Deploy'
  dependsOn: QA
  condition: and(succeeded(),
                 eq(variables.DEPLOY_RENDER, 'true'),
                 ne(variables['RENDER_PROD_HOOK_FRONT'], ''),
                 ne(variables['RENDER_PROD_HOOK_BACK'], ''))
  jobs:
    - deployment: promote_prod
      displayName: 'Promote to :prod + Deploy PROD'
      environment: 'prod'
      strategy:
        runOnce:
          deploy:
            steps:
              - checkout: self
                clean: true

              - bash: |
                  set -e
                  echo "$GHCR_TOKEN" | docker login "$REGISTRY" -u "$GHCR_USERNAME" --password-stdin
                displayName: 'Login GHCR'
                env:
                  GHCR_TOKEN: $(GHCR_TOKEN)
                  GHCR_USERNAME: $(GHCR_USERNAME)
                  REGISTRY: $(REGISTRY)

              - bash: |
                  set -e
                  docker pull $(REGISTRY)/$(GITHUB_ACTOR)/books-backend:latest
                  docker tag  $(REGISTRY)/$(GITHUB_ACTOR)/books-backend:latest $(REGISTRY)/$(GITHUB_ACTOR)/books-backend:prod
                  docker push $(REGISTRY)/$(GITHUB_ACTOR)/books-backend:prod
                displayName: 'Backend • Promote to :prod'

              - bash: |
                  set -e
                  docker build \
                    --build-arg VITE_ENV=prod \
                    -t $(REGISTRY)/$(GITHUB_ACTOR)/books-frontend:prod \
                    frontend
                  docker push $(REGISTRY)/$(GITHUB_ACTOR)/books-frontend:prod
                displayName: 'Frontend PROD • Build (VITE_ENV=prod) & Push :prod'

              - bash: |
                  set -e
                  echo "Trigger Render FRONT PROD"
                  curl -fsS -X POST "$RENDER_PROD_HOOK_FRONT"
                  echo "Trigger Render BACK PROD"
                  curl -fsS -X POST "$RENDER_PROD_HOOK_BACK"
                displayName: 'Deploy PROD (Render hooks)'
                env:
                  RENDER_PROD_HOOK_FRONT: $(RENDER_PROD_HOOK_FRONT)
                  RENDER_PROD_HOOK_BACK: $(RENDER_PROD_HOOK_BACK)
